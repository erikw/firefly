# CMAKE
	We should switch to CMake. I have begun on this branch, it can now
	build the Labcomm compiler (and generate the Labcomm files that are
	needed), libfirefly, libtransport-eth-posix, libtransport-udp-posix
	and libfirefly-event-queue (which isn't needed but was a good
	starting point).

	Need to figure out how to cross compile to arm, how to avoid
	building xenomai (and LWIP-suff) if it's not installed and how to
	build test programs. There are probably some more stuff I've
	forgotten that we need to do but this is a start.

# EVENT CHAINING
    Should implement some sort of chaining of events, e.g. through next
    pointer on events or through on_complete callback functions. This
    would allow us to close channels when a connection is closed, e.g:

	conn_close -> chan_close_ev -> chan_close_ev -> conn_close_ev

    This would save us from relying on event priority to synchronize the
    order of execution of events.

# HALF OPEN CONNECTION
    Impl. half open on connections, can send but not receive on a half
    open.  When closing a connection, it should be set to HALF_OPEN to
    disallow receiving new stuff on it while allowing channel close
    packets to be sent.

    Possibly also implement an ERROR state on the connection.

# TEST STUFF
    The eth_posix test suite fails infrequently on a ubu10.04 32b vm
    with incorrect sender etc. Not reproducible on ubu12.04 64b.

    Try limiting the pingpong suite to first open channel and then
    continue.

# EVENTIFY CONN OPEN
    fix event driven connection open, at least add connection to llp
	- Make add conn to llp an event with highest priority

# FIX RELIABILITY OF SIGNATURES
 - Suggestion, force user to specify the types when opening the channel and
   disallow adding new types after channel is opened. This may be done by
   setting a callback that is called when the types can be registered. The
   purpose of this is to make use of the handshake to request and accept
   labcomm types. Each node will during setup send its signatures. When a
   signature is recieved and verified by the application an ack packet is sent
   for that specific signature. When a node has sent an ack packet for each
   received signature and recieved an ack packet for each transmitted
   signature the channel is considered open and ready.
   The application verifies a signature by making sure the labcomm decoder will
   not generate an error when reading the signature. This is achived by either
   adding the type before the signature is read or by implementing the unknown
   datatype callback and registering the type there.
   Typical usage: 1. define a callback which takes the channel as input, the
   function should use the labcomm api to register each type. 2. Open channel
   and specify the callback. 3. The protocol will call the callback when it is
   ready to send the signatures.

# DECEASE RUNTIME MALLOC
    Ignore any malloc during setup setup:
	- The transport layer makes sure to have mem alvailable to read the data.
	  (no changes, 1 malloc)
	- transport_read creates the read event and sets the data pointer. (may
	  avoid mallocing the event_arg).
	- transport_read_event gives the mem to protocol. Does NOT free it. (no
	  change except for remove free).
	- The mem is th responsibility of protocol now.
	- The protocol labcomm decoder: instead of copying the mem to labcomm
	  internal memory, give the mem directly to labcomm. (no runtime change).
	- Consider future changes to labcomm and fragmentation when doing this.
	  Contact Blomdell about it.
	- Labcomm decoder will alloc the sample data, unavoidable unless labcomm
	  compiler is reqritten.
	- handle_sample_data will take the memory given by the transport layer and
	  copy the sample data to it. This memory is referenced by
	  conn->reader_data->data. (1 malloc less!).
	- handle_sample_data creates the event and gives it a reference to the
	  memory.
	- The handle_sample_data_event gives the memory to labcomm_reader which in
	  turn gives it to labcomm internal.
	- After this point we have no control as the data is on the applayer and
	  consequently the mem must be freed.
	- possible rewrite of labcomm compiler to let the decoder use the data
	  memory instead of allocing a new mem and copying the reader data to it.
	  Only usable with variable length arrays. Other types have much easier
	  solutions.

# RELIABILITY
	- Ack transport packets when closing a channel.
	- conn->transport_ack == NULL should be interpreted as reliability ensured

# PREPARE FOR XENOMAI
	- App layer must be notified before change from pure state to inpure state
	  (using Haskell terminology). Pure would mean a state where nothing is
	  uncertain, no unacked packets, no new connections or channels, no closing
	  channels or connections. Pure is only encoding/decoding packets and
	  sending them.
	- Research wheather is it possible to have 2 separate event loops, one for
	  pure events and one for inpure. This state must be know when allocating
	  new memory.
	- Fix memory allocation in labcomm, can't use malloc for encoding and
	  decoding, should not use malloc or free either to support eg RTOS.
